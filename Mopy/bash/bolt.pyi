import array
from collections import OrderedDict, defaultdict
from contextlib import contextmanager
import ctypes
from functools import cached_property
from io import (
    BufferedRandom, BufferedReader, BufferedWriter, FileIO, TextIOWrapper,
)
import mmap
import os
import pickle
import re
import struct
import subprocess
from typing import (
    Any, AnyStr, BinaryIO, Callable, ClassVar, Generic, Iterable, IO, Literal,
    Mapping, MutableMapping, overload, Protocol, TypeAlias, TypeVar,
)


## Typing helpers
_T = TypeVar('_T')      # Generic type
_KT = TypeVar('_KT')    # Generic key type
_KT2 = TypeVar('_KT2')  # Generic key type
_VT = TypeVar('_VT')    # Generic value type
_Nones: TypeAlias = Literal[
    # All strings that lower to 'none'
    'NONE',
    'NONe', 'NOnE', 'NoNE', 'nONE',
    'NOne', 'NoNe', 'nONe', 'NonE', 'nONe', 'noNE',
    'None', 'nOne', 'noNe', 'nonE',
    'none',
]
_Zeros: TypeAlias = Literal[
    # Just the most common strings that convert as int to 0
    '0', '00', '000', '0000',
    '0.0', '0.00', '0.000', '0.0000',
]
StrPath: TypeAlias = str | os.PathLike[str]

# Bound class types
_CFName = TypeVar('_CFName', bound=FName)
_CFlags = TypeVar('_CFlags', bound=Flags)


_FNameCache: TypeAlias = MutableMapping[str, FName]
_AttrGetterCache: TypeAlias = MutableMapping[str, Callable[[object, str], Any]]

# For struct.Struct related
_Packer: TypeAlias = Callable[..., bytes]
_Unpacker: TypeAlias = Callable[[bytes], tuple[Any, ...]]
class _SupportsRead(Protocol):
    def read(self, size: int | None) -> bytes: ...
class _SupportsWrite(Protocol):
    def write(self, data: ReadableBuffer, /) -> Any: ...

# For Path.open
ReadOnlyBuffer: TypeAlias = bytes
WriteableBuffer: TypeAlias = (
    bytearray | memoryview | array.array[Any] | mmap.mmap | ctypes._CData |
    pickle.PickleBuffer
)
ReadableBuffer: TypeAlias = ReadOnlyBuffer | WriteableBuffer
OpenTextModeUpdating: TypeAlias = Literal[
    'r+', '+r', 'rt+', 'r+t', '+rt', 'tr+', 't+r', '+tr', 'w+', '+w', 'wt+',
    'w+t', '+wt', 'tw+', 't+w', '+tw', 'a+', '+a', 'at+', 'a+t', '+at', 'ta+',
    't+a', '+ta', 'x+', '+x', 'xt+', 'x+t', '+xt', 'tx+', 't+x', '+tx',
]
OpenTextModeWriting: TypeAlias = Literal[
    'w', 'wt', 'tw', 'a', 'at', 'ta', 'x', 'xt', 'tx',
]
OpenTextModeReading: TypeAlias = Literal[
    'r', 'rt', 'tr', 'U', 'rU', 'Ur', 'rtU', 'rUt', 'Urt', 'trU', 'tUr', 'Utr',
]
OpenTextMode: TypeAlias = (
    OpenTextModeUpdating | OpenTextModeWriting | OpenTextModeReading
)
OpenBinaryModeUpdating: TypeAlias = Literal[
    'rb+', 'r+b', '+rb', 'br+', 'b+r', '+br', 'wb+', 'w+b', '+wb', 'bw+',
    'b+w', '+bw', 'ab+', 'a+b', '+ab', 'ba+', 'b+a', '+ba', 'xb+', 'x+b',
    '+xb', 'bx+', 'b+x', '+bx',
]
OpenBinaryModeWriting: TypeAlias = Literal[
    'wb', 'bw', 'ab', 'ba', 'xb', 'bx',
]
OpenBinaryModeReading: TypeAlias = Literal[
    'rb', 'br', 'rbU', 'rUb', 'Urb', 'brU', 'bUr', 'Ubr',
]
OpenBinaryMode: TypeAlias = (
    OpenBinaryModeUpdating | OpenBinaryModeReading | OpenBinaryModeWriting
)
_Opener: TypeAlias = Callable[[str, int], int]


## public bolt defines, in order they appear
struct_pack: Callable[[str, *Any], bytes]
struct_unpack: Callable[[str, ReadableBuffer], tuple[Any, ...]]
struct_error: type[struct.error]
struct_calcsize: Callable[[str], int]

startupinfo: subprocess.STARTUPINFO
os_name: str

encodingOrder: tuple[str, ...]
pluginEncoding: str | None

def getbestencoding(bitstream) -> tuple[str, float]: ...

@overload
def decoder(
    byte_str: None,
    encoding: str | None = ...,
    avoidEncodings: Iterable[str] = ...,
) -> None: ...
@overload
def decoder(
    byte_str: bytes | str,
    encoding: str | None = ...,
    avoidEncodings: Iterable[str] = ...,
) -> str: ...

@overload
def encode(
    text_str: None,
    encodings: Iterable[str] = ...,
    firstEncoding: str | None = ...,
    returnEncoding: Literal[True] = ...,
) -> tuple[None, None]: ...
@overload
def encode(
    text_str: None,
    encodings: Iterable[str] = ...,
    firstEncoding: str | None = ...,
    returnEncoding: Literal[False] = ...,
) -> None: ...
@overload
def encode(
    text_str: bytes,
    encodings: Iterable[str] = ...,
    firstEncoding: str | None = ...,
    returnEncoding: Literal[True] = ...,
) -> tuple[bytes, None]: ...
@overload
def encode(
    text_str: str | bytes,
    encodings: Iterable[str] = ...,
    firstEncoding: str | None = ...,
    returnEncoding: Literal[False] = ...,
) -> bytes: ...
@overload
def encode(
    text_str: str,
    encodings: Iterable[str] = ...,
    firstEncoding: str | None = ...,
    returnEncoding: Literal[True] = ...,
) -> tuple[bytes, str]: ...


def encode_complex_string(
    string_val: str,
    max_size: int | None = ...,
    min_size: int | None = ...,
    preferred_encoding: str | None = ...,
) -> bytes: ...

def to_unix_newlines(s: str) -> str: ...
def remove_newlines(s: str) -> str: ...

@overload
def conv_obj(
    o: bytes,
    conv_enc: str,
    __list_types: Iterable[type] = ...,
) -> str: ...
@overload
def conv_obj(
    o: _T,
    conv_enc: str,
    __list_types: Iterable[type] = ...,
) -> _T: ...

def timestamp() -> str: ...
def round_size(size_bytes: int) -> str: ...

sig_to_str: Callable[[bytes], str]
str_to_sig: Callable[[str], bytes]

def sortFiles(files: Iterable[str]) -> Iterable[str]: ...

@overload
def str_or_none(uni_str: _Nones) -> None: ...
@overload
def str_or_none(uni_str: str) -> str: ...
def int_or_none(uni_str: str) -> int | None: ...
@overload
def int_or_zero(uni_str: _Zeros) -> Literal[0]: ...
@overload
def int_or_zero(uni_str: str) -> int: ...
def float_or_none(uni_str: str) -> float | None: ...

class CIstr(str): ...

class FName(str):
    # Only these are really different than str's versions typing-wise
    @overload
    def __new__(
        cls: type[_CFName],
        unicode_str: None,
        __cache: _FNameCache = ...,
        **kwargs,
    ) -> None: ...
    @overload
    def __new__(
        cls: type[_CFName],
        unicode_str: FName,
        __cache: _FNameCache = ...,
        **kwargs,
    ) -> FName: ...
    @overload
    def __new__(
        cls: type[_CFName],
        unicode_str: str,
        __cache: _FNameCache = ...,
        **kwargs,
    ) -> _CFName: ...

    @cached_property
    def ci_ext(self) -> FName: ...
    @cached_property
    def ci_body(self) -> FName: ...

    def __reduce__(self) -> tuple[
        Callable[[str | Path], Path],
        tuple[str]
    ]: ...
    def __deepcopy__(self, memodict: dict = ...) -> FName: ...
    def __copy__(self) -> FName: ...

# Technically converts inputs to CIStr, but the interface is that of
# dict[str, _VT]
class LowerDict(dict[str, _VT]): ...
class FNDict(dict[FName, _VT]): ...

@overload
def forward_compat_path_to_fn(
    di: Mapping[StrPath, Any],
    value_type: Callable[[Any], _VT] = ...,     # type: ignore
) -> FNDict[_VT]: ...
@overload
def forward_compat_path_to_fn(
    di: Mapping[StrPath, Any],
    value_type: Callable[[Any], Any] = ...,
) -> FNDict[Any]: ...

@overload
def forward_compat_path_to_fn_list(
    li: Iterable[StrPath],
    ret_type: type[list] = ...,
) -> list[FName]: ...
@overload
def forward_compat_path_to_fn_list(
    li: Iterable[StrPath],
    ret_type: type[set] = ...,
) -> set[FName]: ...
@overload
def forward_compat_path_to_fn_list(
    li: Iterable[StrPath],
    ret_type: type[tuple] = ...,
) -> tuple[FName]: ...
@overload
def forward_compat_path_to_fn_list(
    li: Iterable[StrPath],
    ret_type: type[Iterable] = ...,
) -> Iterable[FName]: ...

class DefaultLowerDict(LowerDict[_VT], defaultdict[str, _VT]): ...
class DefaultFNDict(FNDict[_VT], defaultdict[str, _VT]): ...
class OrderedLowerDict(LowerDict[_VT], OrderedDict[str, _VT]): ...

attrgetter_cache: _AttrGetterCache

def setattr_deep(
    obj: object,
    attr: str,
    value: Any,
    __attrgetters: _AttrGetterCache = ...,
    __split_cache: MutableMapping[str, tuple[str, str]] = ...,
) -> None: ...

def top_level_files(directory: StrPath) -> Iterable[FName]: ...
def top_level_dirs(directory: StrPath) -> Iterable[FName]: ...
def top_level_items(directory: StrPath) -> tuple[
    Iterable[FName],
    Iterable[FName]
]: ...

@overload
def GPath(str_or_uni: None) -> None: ...
@overload
def GPath(str_or_uni: StrPath) -> Path: ...
@overload
def GPath_no_norm(str_or_uni: None) -> None: ...
@overload
def GPath_no_norm(str_or_uni: StrPath) -> Path: ...
def GPath_purge() -> None: ...

class Path(os.PathLike[str]):
    sys_fs_enc: ClassVar[str]
    invalid_chars_re = ClassVar[re.Pattern[str]]

    @staticmethod
    def getNorm(str_or_path: StrPath | bytes) -> str: ...
    @staticmethod
    def getcwd() -> Path: ...
    def setcwd(self) -> None: ...
    @staticmethod
    def has_invalid_chars(path_str) -> str | None: ...

    def __init__(self, norm_str: str) -> None: ...
    def __getstate__(self) -> str: ...
    def __setstate__(self, norm: str) -> None: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __fspath__(self) -> str: ...

    @property
    def s(self) -> str: ...
    @property
    def cs(self) -> str: ...
    @property
    def sroot(self) -> str: ...
    @property
    def shead(self) -> str: ...
    @property
    def stail(self) -> str: ...
    @property
    def sbody(self) -> str: ...
    @property
    def headTail(self) -> tuple[Path, Path]: ...
    @property
    def head(self) -> Path: ...
    @property
    def tail(self) -> Path: ...
    @property
    def body(self) -> Path: ...
    @property
    def root(self) -> Path: ...
    @property
    def ext(self) -> str: ...
    @property
    def cext(self) -> str: ...
    @property
    def temp(self) -> Path: ...
    @staticmethod
    def tempDir(prefix: str = ...) -> Path: ...
    @staticmethod
    def baseTempDir() -> Path: ...
    @property
    def backup(self) -> Path: ...
    @property
    def psize(self) -> int: ...
    @property
    def atime(self) -> float: ...
    @property
    def ctime(self) -> float: ...
    @property
    def mtime(self) -> float: ...
    def size_mtime(self) -> tuple[int, float]: ...
    def size_mtime_ctime(self) -> tuple[int, float, float]: ...
    @property
    def stat(self) -> os.stat_result: ...
    @property
    def version(self) -> tuple: ...
    @property
    def strippedVersion(self) -> tuple: ...
    @property
    def crc(self) -> int: ...

    def __add__(self, other: StrPath) -> Path: ...
    def join(*args: StrPath) -> Path: ...
    def ilist(self) -> Iterable[FName]: ...

    def walk(
        self,
        topdown: bool = ...,
        onerror: Callable[[OSError], None] = ...,
        *,
        relative: bool = ...
    ) -> Iterable[tuple[Path, list[Path], list[Path]]]: ...

    def relpath(self, path: StrPath) -> Path: ...
    def drive(self) -> Path: ...
    def exists(self) -> bool: ...
    def is_dir(self) -> bool: ...
    def is_file(self) -> bool: ...
    def is_absolute(self) -> bool: ...
    def clearRO(self) -> None: ...

    @overload
    def open(
        self,
        mode: OpenTextMode = ...,
        buffering: int = ...,
        encoding: str | None = ...,
        errors: str | None = ...,
        newline: str | None = ...,
        closefd: bool = ...,
        opener: _Opener | None = ...,
    ) -> TextIOWrapper: ...
    @overload
    def open(
        self,
        mode: OpenBinaryMode,
        buffering: Literal[0],
        encoding: None = ...,
        errors: None = ...,
        newline: None = ...,
        closefd: bool = ...,
        opener: _Opener | None = ...,
    ) -> FileIO: ...
    @overload
    def open(
        self,
        mode: OpenBinaryModeUpdating,
        buffering: Literal[-1, 1] = ...,
        encoding: None = ...,
        errors: None = ...,
        newline: None = ...,
        closefd: bool = ...,
        opener: _Opener | None = ...,
    ) -> BufferedRandom: ...
    @overload
    def open(
        self,
        mode: OpenBinaryModeWriting,
        buffering: Literal[-1, 1] = ...,
        encoding: None = ...,
        errors: None = ...,
        newline: None = ...,
        closefd: bool = ...,
        opener: _Opener | None = ...,
    ) -> BufferedWriter: ...
    @overload
    def open(
        self,
        mode: OpenBinaryModeReading,
        buffering: Literal[-1, 1] = ...,
        encoding: None = ...,
        errors: None = ...,
        newline: None = ...,
        closefd: bool = ...,
        opener: _Opener | None = ...,
    ) -> BufferedReader: ...
    @overload
    def open(
        self,
        mode: OpenBinaryMode,
        buffering: int = ...,
        encoding: None = ...,
        errors: None = ...,
        newline: None = ...,
        closefd: bool = ...,
        opener: _Opener | None = ...,
    ) -> BinaryIO: ...
    @overload
    def open(
        self,
        mode: str,
        buffering: int = ...,
        encoding: str | None = ...,
        errors: str | None = ...,
        newline: str | None = ...,
        closefd: bool = ...,
        opener: _Opener | None = ...,
    ) -> IO[Any]: ...

    def makedirs(self) -> None: ...
    def remove(self) -> None: ...
    def removedirs(self) -> None: ...
    def rmtree(self, safety: str = ...) -> None: ...
    def start(self, exeArgs: list[str] | None = ...) -> None: ...
    def copyTo(self, destName: StrPath) -> None: ...
    def moveTo(self, destName: StrPath, check_exist: bool = ...) -> None: ...
    def untemp(self, doBackup: bool = ...) -> None: ...
    def editable(self) -> bool: ...

    def __hash__(self) -> int: ...
    def __eq__(self, other: str | Path) -> bool: ...
    def __ne__(self, other: str | Path) -> bool: ...
    def __lt__(self, other: str | Path) -> bool: ...
    def __ge__(self, other: str | Path) -> bool: ...
    def __gt__(self, other: str | Path) -> bool: ...
    def __le__(self, other: str | Path) -> bool: ...
    def __deepcopy__(self, memodict: dict = ...) -> Path: ...
    def __copy__(self) -> Path: ...

class LooseVersion:
    def __init__(self, ver_string: str) -> None: ...
    def __repr__(self) -> str: ...
    def __eq__(self, other: LooseVersion) -> bool: ...
    def __ne__(self, other: LooseVersion) -> bool: ...
    def __lt__(self, other: LooseVersion) -> bool: ...
    def __le__(self, other: LooseVersion) -> bool: ...
    def __gt__(self, other: LooseVersion) -> bool: ...
    def __ge__(self, other: LooseVersion) -> bool: ...

def popen_common(popen_cmd: list[str], **kwargs) -> subprocess.Popen: ...
def clearReadOnly(dirPath: StrPath) -> None: ...

reUnixNewLine: re.Pattern[str]

class Flags:
    @classmethod
    def from_names(
        cls: type[_CFlags],
        *names: str | tuple[int, str],
    ) -> type[_CFlags]: ...

    def __init__(self, value: int = ...) -> None: ...
    def __call__(self, newValue: int | None = ...) -> Flags: ...
    def __deepcopy__(self, memo: dict) -> Flags: ...
    def __copy__(self) -> Flags: ...
    def hex(self) -> str: ...
    def dump(self) -> int: ...
    def __int__(self) -> int: ...
    def __index__(self) -> int: ...
    def __getitem__(self, index: int) -> bool: ...
    def __setitem__(self, index: int, value: bool) -> None: ...
    def __getattr__(self, attr_key: str) -> bool: ...
    def __setattr__(self, attr_key: str, value: bool) -> None: ...
    def __eq__(self, other: Flags | int) -> bool: ...
    def __ne__(self, other: Flags | int) -> bool: ...
    def __and__(self, other: Flags | int) -> Flags: ...
    def __invert__(self) -> Flags: ...
    def __or__(self, other: Flags | int) -> Flags: ...
    def __xor__(self, other: Flags | int) -> Flags: ...
    def getTrueAttrs(self) -> tuple[str]: ...
    def __repr__(self) -> str: ...

class TrimmedFlags(Flags): ...

class DataDict(dict[_KT, _VT]): ...

class AFile:
    fsize: int

    def __init__(
        self,
        fullPath: StrPath,
        load_cache: bool = ...,
        raise_on_error: bool = ...,
    ) -> None: ...

    @property
    def abs_path(self) -> Path: ...
    def do_update(
        self,
        raise_on_error: bool = ...,
        itsa_ghost: bool | None = ...,
    ) -> bool: ...

    def needs_update(self) -> bool: ...
    def __repr__(self) -> str: ...

class MainFunctions:
    def __init__(self) -> None: ...
    def add(self, func: Callable, func_key: str | None = ...) -> Callable: ...
    def main(self) -> None: ...

def mainfunc(func: Callable) -> Callable: ...

class PickleDict(Generic[_VT]):
    backup: Path
    readOnly: bool
    vdata: MutableMapping[str, _VT]
    pickled_data: MutableMapping[str, _VT]

    def __init__(
        self,
        pkl_path: Path,
        readOnly: bool = ...,
        load_pickle: bool = ...,
    ) -> None: ...

    def exists(self) -> bool: ...

    class Mold(Exception):
        def __init__(self, moldedFile: StrPath) -> None: ...
    
    def load(self) -> Literal[0, 1, 2]: ...
    def save(self) -> bool: ...

class Settings(DataDict[str, Any]):
    dictFile: PickleDict[Any]
    vdata: MutableMapping[str, Any]
    defaults: Mapping[str, Any]

    def __init__(self, dictFile: PickleDict[Any]) -> None: ...
    def loadDefaults(self, default_settings: Mapping[str, Any]) -> None: ...
    def save(self) -> None: ...

structs_cache: MutableMapping[str, struct.Struct]

def unpack_str16(ins: _SupportsRead, __unpack: _Unpacker = ...) -> bytes: ...
def unpack_str32(ins: _SupportsRead, __unpack: _Unpacker = ...) -> bytes: ...
def unpack_int(ins: _SupportsRead, __unpack: _Unpacker = ...) -> int: ...
def pack_int(out: _SupportsWrite, value: int, __pack: _Packer = ...) -> None: ...
def unpack_short(ins: _SupportsRead, __unpack: _Unpacker = ...) -> int: ...
def pack_short(out: _SupportsWrite, value: int, __pack: _Packer = ...) -> None: ...
def unpack_float(ins: _SupportsRead, __unpack: _Unpacker = ...) -> float: ...
def pack_float(out: _SupportsWrite, value: float, __pack: _Packer = ...) -> None: ...
def unpack_double(ins: _SupportsRead, __unpack: _Unpacker = ...) -> float: ...
def pack_double(out: _SupportsWrite, value: float, __pack: _Packer = ...) -> None: ...
def unpack_byte(ins: _SupportsRead, __unpack: _Unpacker = ...) -> int: ...
def pack_byte(out: _SupportsWrite, value: int, __pack: _Packer = ...) -> None: ...
def unpack_int_signed(ins: _SupportsRead, __unpack: _Unpacker = ...) -> int: ...
def pack_int_signed(out: _SupportsWrite, value: int, __pack: _Packer = ...) -> None: ...
def unpack_int64_signed(ins: _SupportsRead, __unpack: _Unpacker = ...) -> int: ...
def pack_int64_signed(ins: _SupportsWrite, value: int, __pack: _Packer = ...) -> None: ...
def unpack_4s(ins: _SupportsRead, __unpack: _Unpacker = ...) -> bytes: ...
def pack_4s(out: _SupportsWrite, value: bytes, __pack: _Packer = ...) -> None: ...
def unpack_str16_delim(ins: _SupportsRead, __unpack: _Unpacker = ...) -> bytes: ...
def unpack_str_int_delim(ins: _SupportsRead, __unpack: _Unpacker = ...) -> int: ...
def unpack_str_byte_delim(ins: _SupportsRead, __unpack: _Unpacker = ...) -> int: ...
def unpack_str8(ins: _SupportsRead, __unpack: _Unpacker = ...) -> bytes: ...
def pack_str8(out: _SupportsWrite, value: bytes, __pack: _Packer = ...) -> None: ...
def pack_bzstr8(out: _SupportsWrite, value: bytes, __pack: _Packer = ...) -> None: ...
def unpack_string(ins: _SupportsRead, string_len: int) -> bytes: ...
def pack_string(out: _SupportsWrite, value: bytes) -> None: ...
def pack_byte_signed(out: _SupportsWrite, value: int, __pack: _Packer = ...) -> None: ...
def unpack_many(ins: _SupportsRead, fmt: str) -> tuple[Any, ...]: ...
def unpack_spaced_string(ins: _SupportsRead, replacement_char: bytes = ...) -> bytes: ...

class DataTableColumn(MutableMapping[_KT, _VT]):
    column: DataTableColumn[_KT, _VT]

    def __init__(
        self,
        table: DataTable[_KT, _VT],
        column: DataTableColumn[_KT, _VT]) -> None: ...

class DataTable(DataDict[_KT, MutableMapping[_KT, _VT]]):
    dictFile: PickleDict[_VT]
    vdata: MutableMapping[_KT, _VT]
    hasChanged: bool

    def __init__(self, dictFile: PickleDict[_VT]) -> None: ...
    def save(self) -> None: ...

    @overload
    def getItem(
        self,
        row: _KT,
        column: _KT,
        default: None = ...
    ) -> _KT | None: ...
    @overload
    def getItem(
        self,
        row: _KT,
        column: _KT,
        default: _VT = ...
    ) -> _VT: ...

    def getColumn(self, column: _KT) -> DataTableColumn[_KT, _VT]: ...
    def setItem(self, row: _KT, column: _KT, value: _VT) -> None: ...
    def delItem(self, row: _KT, column: _KT) -> None: ...
    def delRow(self, row: _KT) -> None: ...
    def delColumn(self, column: _KT) -> None: ...
    def moveRow(self, oldRow: _KT, newRow: _KT) -> None: ...
    def copyRow(self, oldRow: _KT, newRow: _KT) -> None: ...

    def __setitem__(
        self,
        row: _KT,
        value: DataTableColumn[_KT, _VT],
    ) -> None: ...
    def __delitem__(self, row: _KT) -> None: ...

    @overload
    def pop(
        self,
        row: _KT,
        default: None = ...,
    ) -> DataTableColumn[_KT, _VT] | None: ...
    @overload
    def pop(
        self,
        row: _KT,
        default: DataTableColumn[_KT, _VT] = ...,
    ) -> DataTableColumn[_KT, _VT]: ...

def cmp_(x: Any, y: Any) -> int: ...

class Rounder(float):
    def dump(self) -> Rounder: ...

def cstrip(inString: AnyStr) -> AnyStr: ...
def text_wrap(text_to_wrap: str, width: int = ...) -> str: ...

deprintOn: bool

def deprint(
    *args: Any,
    traceback: bool = ...,
    trace: bool = ...,
    frame: int = ...,
    on: bool = ...
) -> None: ...

@contextmanager     # type: ignore
def redirect_stdout_to_deprint(use_bytes: bool = ...) -> None: ...

@overload
def getMatch(reMatch: None, group: int = ...) -> Literal['']: ...
@overload
def getMatch(reMatch: re.Match, group: int = ...) -> str: ...

def winNewLines(inString: str) -> str: ...

class Log:
    def __init__(self) -> None: ...
    def setHeader(
        self,
        header: str,
        writeNow: bool = ...,
        doFooter: bool = ...,
    ) -> None: ...
    def __call__(
        self,
        message: str | None = ...,
        appendNewLine: bool = ...,
    ) -> None: ...
    def writeLogHeader(self, header: str) -> None: ...
    def writeFooter(self) -> None: ...
    def writeMessage(self, message: str, appendNewLine: bool) -> None: ...

class LogFile(Log):
    out: _SupportsWrite
    def __init__(self, out: _SupportsWrite) -> None: ...

class Progress:
    message: str
    full: float
    state: int

    def __init__(self, full: float = ...) -> None: ...
    def getParent(self) -> None: ...
    def setFull(self, full: int | float) -> Progress: ...
    def plus(self, increment: int = ...) -> None: ...
    def __call__(self, state: int, message: str = ...) -> None: ...
    def __enter__(self) -> Progress: ...
    def __exit__(
        self,
        exc_type: Any,
        exc_value: Any,
        exc_traceback: Any,
    ) -> None: ...

class SubProgress(Progress):
    parent: Progress
    baseFrom: float
    scale: float
    silent: bool

    def __init__(
        self,
        parent: Progress,
        baseFrom: float = ...,
        baseTo: float | Literal['+1'] = ...,
        full: float = ...,
        silent: bool = ...,
    ) -> None: ...

def readCString(ins: _SupportsRead, file_path: StrPath) -> bytes: ...

class StringTable(dict[int, str]):
    encodings: ClassVar[MutableMapping[str, str]]

    def loadFile(
        self,
        path: Path,
        progress: Progress,
        lang: str = ...
    ) -> None: ...

def build_esub(esub_str: str) -> Callable[[re.Match[str]], str]: ...

class RecPath:
    def __init__(self, rpath_str: str) -> None: ...
    def rp_eval(self, record: Any) -> Any: ...
    def rp_map(self, record: Any) -> Any: ...
    def __repr__(self) -> str: ...

def natural_key() -> Callable[[str], list[int | str]]: ...

def dict_sort(
    di: Mapping[_KT, _VT],
    values_dex: Iterable[_VT] = ...,
    by_value: bool = ...,
    key_f: Callable[[_KT], Any] = ...,
    reverse: bool = ...,
) -> Iterable[tuple[_KT, _VT]]: ...

def readme_url(
    mopy: Path,
    advacned: bool = ...,
    skip_locak: bool = ...,
) -> str: ...

codebox: Callable[[Iterable[str], bool, bool], None]

class WryeText:
    htmlHead: ClassVar[str]
    defaultCss: ClassVar[str]

    @staticmethod
    def genHtml(
        ins: StrPath,
        out: _SupportsWrite | None = ...,
        *css_dirs: StrPath
    ) -> None: ...

def convert_wtext_to_html(
    logPath: Path,
    logText: str,
    *css_dirs: StrPath,
) -> None: ...
